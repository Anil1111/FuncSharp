<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="../../CodeGen/Helpers.ttinclude" #>
using System;

namespace FuncSharp
{
    /// <summary>
    /// Base class and factory of canonical sum types.
    /// </summary>
    public abstract partial class Sum : ISum
    {
        protected internal Sum(int arity, int discriminator, object value)
        {
            if (arity <= 0)
            {
                throw new ArgumentException("The arity must be a positive number.");
            }
            if (discriminator < 1 || arity < discriminator)
            {
                throw new ArgumentException("The discriminator must be from interval [1, arity].");
            }

            SumArity = arity;
            SumDiscriminator = discriminator;
            SumValue = value;
        }

        public int SumArity { get; private set; }

        public int SumDiscriminator { get; private set; }

        public object SumValue { get; private set; }
<# for (var i = 1; i < MaxArity(); i++) { #>
<#     for (var j = 1; j <= i; j++) { #>

        /// <summary>
        /// Creates a new <#= i #>-dimensional sum with the <#= GetLowerOrdinal(i) #> value.
        /// </summary>
        public static <#= SumType(i) #> Create<#= GetOrdinal(j) #><#= TypeBracket(i) #>(<#= Parameter(j) #>)
        {
            return new <#= SumType(i) #>(<#= j #>, <#= Value(j) #>);
        }
<#     } #>
<# } #>

        public override int GetHashCode()
        {
            return this.SumHashCode();
        }

        public override bool Equals(object obj)
        {
            return this.SumEquals(obj);
        }

        public override string ToString()
        {
            return this.SumToString();
        }

        protected T GetSumValue<T>()
        {
            if (SumValue is T)
            {
                return (T)SumValue;
            }
            return default(T);
        }
    }

<# for (var i = 0; i < MaxArity(); i++) { #>
    /// <summary>
    /// A <#= i #>-dimensional sum.
    /// </summary> 
    public class <#= SumType(i) #> : Sum
    {
        /// <summary>
        /// Creates a new <#= i #>-dimensional sum.
        /// </summary>
        internal Sum<#= i #>(int discriminator, object value)
            : base(<#= i #>, discriminator, value)
        {
        }
<#     for (var j = 1; j <= i; j++) { #>

        /// <summary>
        /// Returns whether the sum contains the <#= GetLowerOrdinal(j) #> value.
        /// </summary>
        public bool Is<#= GetOrdinal(j) #>
        {
            get { return SumDiscriminator == <#= j #>; }
        }

        /// <summary>
        /// Returns <#= GetLowerOrdinal(j) #> value of the sum as an option. The option contains the <#= GetLowerOrdinal(j) #> value
        /// or is empty if the sum contains different value.
        /// </summary>
        public IOption<<#= Type(j) #>> <#= GetOrdinal(j) #>
        {
            get
            {
                return PartialMatch(
                    if<#= GetOrdinal(j) #>: v => Option.Some(v),
                    otherwise: _ => Option.None<<#= Type(j) #>>()
                );
            }
        }
<#     } #>
<#     if (i > 0) { #>

        /// <summary>
        /// Returns result of a function that corresponds to the sum value. E.g. if the sum is the first value, returns result
        /// of the <paramref name="ifFirst" /> function.
        /// </summary>
        public R Match<R>(
<#= Lines(i, x => Indent(12) + "Func<T" + x + ", R> " + IfFunction(x), separator: ",") #>)
        {
            switch (SumDiscriminator)
            {
<#= Lines(i, x => Indent(16) + "case " + x + ": return " + IfFunction(x) + "(GetSumValue<T" + x + ">());") #>
                default: return default(R); // Never happens.
            }
        }

        /// <summary>
        /// Returns result of a function that corresponds to the sum value similarly to match. If the function is null, returns result
        /// of the <paramref name="otherwise">otherwise</paramref> function. If the <paramref name="otherwise">otherwise</paramref> function 
        /// is null, returns default value of the result type. 
        /// </summary>
        public R PartialMatch<R>(
<#= Lines(i, x => Indent(12) + "Func<T" + x + ", R> " + IfFunction(x) + " = null", separator: ",") #>,
            Func<object, R> otherwise = null)
        {
            otherwise = otherwise ?? (_ => default(R));
            return Match(
<#= Lines(i, x => Indent(16) + "v => " + IfFunction(x) + " == null ? otherwise(v) : " + IfFunction(x) + "(v)", separator: ",") #>
            );
        }
<#     } #>
    }

<# } #>
}

<#+
    public string IfFunction(int i)
    {
        return "if" + GetOrdinal(i);
    }

#>
