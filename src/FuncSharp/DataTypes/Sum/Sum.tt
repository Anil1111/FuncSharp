<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="../../CodeGen/Helpers.ttinclude" #>
using System;

namespace FuncSharp
{
    /// <summary>
    /// Base class and factory of canonical sum types.
    /// </summary>
    public abstract class Sum : ISum
    {
        public Sum(int arity, int discriminator, object value)
        {
            if (arity <= 0)
            {
                throw new ArgumentException("The arity must be a positive number.");
            }
            if (discriminator < 1 || arity < discriminator)
            {
                throw new ArgumentException("The discriminator must be from interval [1, arity].");
            }

            SumArity = arity;
            SumDiscriminator = discriminator;
            SumValue = value;
        }

        public int SumArity { get; private set; }

        public int SumDiscriminator { get; private set; }

        public object SumValue { get; private set; }

<# for (var i = 1; i < MaxArity(); i++) { #>
<#     for (var j = 1; j <= i; j++) { #>
        /// <summary>
        /// Creates a new <#= i #>-dimensional sum with the <#= GetLowerOrdinal(i) #> value.
        /// </summary>
        public static <#= SumType(i) #> Create<#= GetOrdinal(j) #><#= TypeBracket(i) #>(<#= Parameter(j) #>)
        {
            return new <#= SumTypeImpl(i) #>(<#= j #>, <#= Value(j) #>);
        }

<#     } #>
<# } #>
        public override int GetHashCode()
        {
            return this.SumHashCode();
        }

        public override bool Equals(object obj)
        {
            return this.SumEquals(obj);
        }

        public override string ToString()
        {
            return this.SumToString();
        }

        protected T GetSumValue<T>()
        {
            if (SumValue is T)
            {
                return (T)SumValue;
            }
            return default(T);
        }
    }

<# for (var i = 0; i < MaxArity(); i++) { #>
    /// <summary>
    /// A <#= i #>-dimensional immutable sum.
    /// </summary> 
    public class <#= SumTypeImpl(i) #> : Sum, <#= SumType(i) #>
    {
        /// <summary>
        /// Creates a new <#= i #>-dimensional sum.
        /// </summary>
        /// <param name="discriminator">Discriminator of the value from interval [1, arity].</param>
        /// <param name="value">Value of the sum on the position defined by the discriminator.</param>
        public Sum<#= i #>(int discriminator, object value)
            : base(<#= i #>, discriminator, value)
        {
        }

<#     for (var j = 1; j <= i; j++) { #>
        public bool Is<#= GetOrdinal(j) #>
        {
            get { return SumDiscriminator == <#= j #>; }
        }

        public IOption<<#= Type(j) #>> <#= GetOrdinal(j) #>
        {
            get
            {
                return PartialMatch(
                    if<#= GetOrdinal(j) #>: v => Option.Some(v),
                    otherwise: _ => Option.None<<#= Type(j) #>>()
                );
            }
        }

<#     } #>
<#     if (i > 0) { #>
        public R Match<R>(
<#= Lines(i, x => Indent(12) + "Func<T" + x + ", R> " + IfIth(x), separator: ",") #>)
        {
            switch (SumDiscriminator)
            {
<#= Lines(i, x => Indent(16) + "case " + x + ": return " + IfIth(x) + "(GetSumValue<T" + x + ">());") #>
                default: return default(R); // Never happens.
            }
        }

        public void Match(
<#= Lines(i, x => Indent(12) + "Action<T" + x + "> " + IfIth(x), separator: ",") #>)
        {
            Match(
<#= Lines(i, x => Indent(16) + IfIth(x) + ".ToFunc()", separator: ",") #>
            );
        }

        public R PartialMatch<R>(
<#= Lines(i, x => Indent(12) + "Func<T" + x + ", R> " + IfIth(x) + " = null", separator: ",") #>,
            Func<object, R> otherwise = null)
        {
            otherwise = otherwise ?? (_ => default(R));
            return Match(
<#= Lines(i, x => Indent(16) + "v => " + IfIth(x) + " == null ? otherwise(v) : " + IfIth(x) + "(v)", separator: ",") #>
            );
        }

        public void PartialMatch(
<#= Lines(i, x => Indent(12) + "Action<T" + x + "> " + IfIth(x) + " = null", separator: ",") #>,
            Action<object> otherwise = null)
        {
            PartialMatch(
<#= Lines(i, x => Indent(16) + IfIth(x) + ".ToFunc()", separator: ",") #>,
                otherwise.ToFunc()
            );
        }
<#     } #>
    }

<# } #>
}
