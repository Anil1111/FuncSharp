<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="../../CodeGen/Helpers.ttinclude" #>
using System;
using System.Collections.Generic;
using System.Linq;

namespace FuncSharp
{
    public partial class Product
    {
<#  for (var i = 0; i < MaxArity(); i++) { #>
        /// <summary>
        /// Creates a new <#= i #>-dimensional product.
        /// </summary>
        public static <#= ProductType(i) #> Create<#= TypeBracket(i) #>(<#= Parameters(i) #>)
        {
            return new <#= ProductType(i) #>(<#= Values(i) #>);
        }

<#  } #>
    }

<#  for (var i = 0; i < MaxArity(); i++) { #>
    /// <summary>
    /// A <#= i #>-dimensional strongly-typed immutable product.
    /// </summary>
    public class <#= ProductType(i) #> : Product
    {
        /// <summary>
        /// Creates a new <#= i #>-dimensional product.
        /// </summary>
        internal Product<#= i #>(<#= Parameters(i) #>)
        {
<#      for (var j = 1; j <= i; j++) { #>
            <#= Property(j) #> = <#= Value(j) #>;
<#      } #>
        }
<#      for (var j = 1; j <= i; j++) { #>

        /// <summary>
        /// Value of the product in the dimension <#= j #>.
        /// </summary>
        public <#= Type(j) #> <#= Property(j) #> { get; private set; }
<#      } #>
<#      for (var j = 1; j <= i; j++) { #>

        /// <summary>
        /// The same product with <#= Property(j) #> omitted.
        /// </summary>
        public <#= ProductType(i, except: j) #> ExceptValue<#= j #>
        {
            get { return Product.Create(<#= Properties(i, except: j) #>); }
        }
<#      } #>

        /// <summary>
        /// Values of the product in order of the dimensions.
        /// </summary>
        public override IEnumerable<object> Values
        {
            get
            {
<#      if (i > 0) { #>
<#          for (var j = 1; j <= i; j++) { #>
                yield return <#= Property(j) #>;
<#          } #>
<#      } else { #>
                return Enumerable.Empty<object>();
<#      } #>
            }
        }
<#      if (i > 0 && i < 8) { #>

        /// <summary>
        /// Converts the product into a tuple.
        /// </summary>
        public Tuple<#= TypeBracket(i) #> ToTuple()
        {
            return Tuple.Create(<#= Properties(i) #>);
        }
<#      } #>
    }

<#  } #>
}
