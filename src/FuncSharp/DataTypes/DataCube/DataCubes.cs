using System;
using System.Collections.Generic;
using System.Linq;

namespace FuncSharp
{
    /// <summary>
    /// A 0-dimensional data cube.
    /// </summary>
    public class DataCube0<TValue> : DataCube<IProduct0, TValue>
    {
        public DataCube0()
        {
        }

        /// <summary>
        /// The only value in the cube.
        /// </summary>
        public IOption<TValue> Value 
        { 
            get { return Get(); }
        }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains()
        {
            return Contains(Product.Create());
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public IOption<TValue> Get()
        {
            return Get(Product.Create());
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(Func<TValue> setter)
        {
            return GetOrElseSet(Product.Create(), setter);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(IProduct0 position, TValue value)
        {

            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(TValue value)
        {
            return Set(Product.Create(), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public void SetOrElseUpdate(TValue value, Func<TValue, TValue, TValue> updater)
        {
            SetOrElseUpdate(Product.Create(), value, updater);
        }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<TValue> a)
        {
            ForEach((position, value) => a(value));
        }
    }

    /// <summary>
    /// A 1-dimensional data cube.
    /// </summary>
    public class DataCube1<P1, TValue> : DataCube<IProduct1<P1>, TValue>
    {
        public DataCube1()
        {
            Domain1Counts = new Dictionary<IProduct1<P1>, int>();
        }

        /// <summary>
        /// Positions of values in the first dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P1> Domain1
        {
            get { return Domain1Counts.Keys.Select(p => p.ProductValue1); }
        }

        private Dictionary<IProduct1<P1>, int> Domain1Counts { get; set; }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(P1 p1)
        {
            return Contains(Product.Create(p1));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public IOption<TValue> Get(P1 p1)
        {
            return Get(Product.Create(p1));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(P1 p1, Func<TValue> setter)
        {
            return GetOrElseSet(Product.Create(p1), setter);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(IProduct1<P1> position, TValue value)
        {
            AddDomain(Domain1Counts, position.ProductValue1);

            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(P1 p1, TValue value)
        {
            return Set(Product.Create(p1), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public void SetOrElseUpdate(P1 p1, TValue value, Func<TValue, TValue, TValue> updater)
        {
            SetOrElseUpdate(Product.Create(p1), value, updater);
        }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<P1, TValue> a)
        {
            ForEach((position, value) => a(position.ProductValue1, value));
        }
    }

    /// <summary>
    /// A 2-dimensional data cube.
    /// </summary>
    public class DataCube2<P1, P2, TValue> : DataCube<IProduct2<P1, P2>, TValue>
    {
        public DataCube2()
        {
            Domain1Counts = new Dictionary<IProduct1<P1>, int>();
            Domain2Counts = new Dictionary<IProduct1<P2>, int>();
        }

        /// <summary>
        /// Positions of values in the first dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P1> Domain1
        {
            get { return Domain1Counts.Keys.Select(p => p.ProductValue1); }
        }

        /// <summary>
        /// Positions of values in the second dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P2> Domain2
        {
            get { return Domain2Counts.Keys.Select(p => p.ProductValue1); }
        }

        private Dictionary<IProduct1<P1>, int> Domain1Counts { get; set; }

        private Dictionary<IProduct1<P2>, int> Domain2Counts { get; set; }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(P1 p1, P2 p2)
        {
            return Contains(Product.Create(p1, p2));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public IOption<TValue> Get(P1 p1, P2 p2)
        {
            return Get(Product.Create(p1, p2));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(P1 p1, P2 p2, Func<TValue> setter)
        {
            return GetOrElseSet(Product.Create(p1, p2), setter);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(IProduct2<P1, P2> position, TValue value)
        {
            AddDomain(Domain1Counts, position.ProductValue1);
            AddDomain(Domain2Counts, position.ProductValue2);

            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(P1 p1, P2 p2, TValue value)
        {
            return Set(Product.Create(p1, p2), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public void SetOrElseUpdate(P1 p1, P2 p2, TValue value, Func<TValue, TValue, TValue> updater)
        {
            SetOrElseUpdate(Product.Create(p1, p2), value, updater);
        }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<P1, P2, TValue> a)
        {
            ForEach((position, value) => a(position.ProductValue1, position.ProductValue2, value));
        }
    }

    /// <summary>
    /// A 3-dimensional data cube.
    /// </summary>
    public class DataCube3<P1, P2, P3, TValue> : DataCube<IProduct3<P1, P2, P3>, TValue>
    {
        public DataCube3()
        {
            Domain1Counts = new Dictionary<IProduct1<P1>, int>();
            Domain2Counts = new Dictionary<IProduct1<P2>, int>();
            Domain3Counts = new Dictionary<IProduct1<P3>, int>();
        }

        /// <summary>
        /// Positions of values in the first dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P1> Domain1
        {
            get { return Domain1Counts.Keys.Select(p => p.ProductValue1); }
        }

        /// <summary>
        /// Positions of values in the second dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P2> Domain2
        {
            get { return Domain2Counts.Keys.Select(p => p.ProductValue1); }
        }

        /// <summary>
        /// Positions of values in the third dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P3> Domain3
        {
            get { return Domain3Counts.Keys.Select(p => p.ProductValue1); }
        }

        private Dictionary<IProduct1<P1>, int> Domain1Counts { get; set; }

        private Dictionary<IProduct1<P2>, int> Domain2Counts { get; set; }

        private Dictionary<IProduct1<P3>, int> Domain3Counts { get; set; }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(P1 p1, P2 p2, P3 p3)
        {
            return Contains(Product.Create(p1, p2, p3));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public IOption<TValue> Get(P1 p1, P2 p2, P3 p3)
        {
            return Get(Product.Create(p1, p2, p3));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(P1 p1, P2 p2, P3 p3, Func<TValue> setter)
        {
            return GetOrElseSet(Product.Create(p1, p2, p3), setter);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(IProduct3<P1, P2, P3> position, TValue value)
        {
            AddDomain(Domain1Counts, position.ProductValue1);
            AddDomain(Domain2Counts, position.ProductValue2);
            AddDomain(Domain3Counts, position.ProductValue3);

            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(P1 p1, P2 p2, P3 p3, TValue value)
        {
            return Set(Product.Create(p1, p2, p3), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public void SetOrElseUpdate(P1 p1, P2 p2, P3 p3, TValue value, Func<TValue, TValue, TValue> updater)
        {
            SetOrElseUpdate(Product.Create(p1, p2, p3), value, updater);
        }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<P1, P2, P3, TValue> a)
        {
            ForEach((position, value) => a(position.ProductValue1, position.ProductValue2, position.ProductValue3, value));
        }
    }

    /// <summary>
    /// A 4-dimensional data cube.
    /// </summary>
    public class DataCube4<P1, P2, P3, P4, TValue> : DataCube<IProduct4<P1, P2, P3, P4>, TValue>
    {
        public DataCube4()
        {
            Domain1Counts = new Dictionary<IProduct1<P1>, int>();
            Domain2Counts = new Dictionary<IProduct1<P2>, int>();
            Domain3Counts = new Dictionary<IProduct1<P3>, int>();
            Domain4Counts = new Dictionary<IProduct1<P4>, int>();
        }

        /// <summary>
        /// Positions of values in the first dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P1> Domain1
        {
            get { return Domain1Counts.Keys.Select(p => p.ProductValue1); }
        }

        /// <summary>
        /// Positions of values in the second dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P2> Domain2
        {
            get { return Domain2Counts.Keys.Select(p => p.ProductValue1); }
        }

        /// <summary>
        /// Positions of values in the third dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P3> Domain3
        {
            get { return Domain3Counts.Keys.Select(p => p.ProductValue1); }
        }

        /// <summary>
        /// Positions of values in the fourth dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P4> Domain4
        {
            get { return Domain4Counts.Keys.Select(p => p.ProductValue1); }
        }

        private Dictionary<IProduct1<P1>, int> Domain1Counts { get; set; }

        private Dictionary<IProduct1<P2>, int> Domain2Counts { get; set; }

        private Dictionary<IProduct1<P3>, int> Domain3Counts { get; set; }

        private Dictionary<IProduct1<P4>, int> Domain4Counts { get; set; }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(P1 p1, P2 p2, P3 p3, P4 p4)
        {
            return Contains(Product.Create(p1, p2, p3, p4));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public IOption<TValue> Get(P1 p1, P2 p2, P3 p3, P4 p4)
        {
            return Get(Product.Create(p1, p2, p3, p4));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(P1 p1, P2 p2, P3 p3, P4 p4, Func<TValue> setter)
        {
            return GetOrElseSet(Product.Create(p1, p2, p3, p4), setter);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(IProduct4<P1, P2, P3, P4> position, TValue value)
        {
            AddDomain(Domain1Counts, position.ProductValue1);
            AddDomain(Domain2Counts, position.ProductValue2);
            AddDomain(Domain3Counts, position.ProductValue3);
            AddDomain(Domain4Counts, position.ProductValue4);

            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(P1 p1, P2 p2, P3 p3, P4 p4, TValue value)
        {
            return Set(Product.Create(p1, p2, p3, p4), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public void SetOrElseUpdate(P1 p1, P2 p2, P3 p3, P4 p4, TValue value, Func<TValue, TValue, TValue> updater)
        {
            SetOrElseUpdate(Product.Create(p1, p2, p3, p4), value, updater);
        }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<P1, P2, P3, P4, TValue> a)
        {
            ForEach((position, value) => a(position.ProductValue1, position.ProductValue2, position.ProductValue3, position.ProductValue4, value));
        }
    }

}