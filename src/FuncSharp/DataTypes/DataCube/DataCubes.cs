using System;
using System.Collections.Generic;
using System.Linq;

namespace FuncSharp
{
    /// <summary>
    /// A 0-dimensional data cube.
    /// </summary>
    public class DataCube0<TValue> : DataCube<IProduct0, TValue>
    {
        /// <summary>
        /// Creates an empty 0-dimensional data cube. 
        /// </summary>
        public DataCube0()
        {
        }

        /// <summary>
        /// Creates a 0-dimensional data cube filled with the specified data. If multiple values with the same position
        /// appear among the initial data, last one is used.
        /// </summary>
        public DataCube0(IEnumerable<IProduct2<IProduct0, TValue>> initialData)
            : this()
        {
            foreach (var d in initialData)
            {
                Set(d.ProductValue1, d.ProductValue2);
            }
        }

        /// <summary>
        /// The only value in the cube.
        /// </summary>
        public IOption<TValue> Value 
        { 
            get { return Get(); }
        }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<TValue> a)
        {
            ForEach((position, value) => a(value));
        }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains()
        {
            return Contains(Product.Create());
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public IOption<TValue> Get()
        {
            return Get(Product.Create());
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(Func<Unit, TValue> setter)
        {
            return GetOrElseSet(Product.Create(), setter);
        }
        
        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(IProduct0 position, TValue value)
        {
            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(TValue value)
        {
            return Set(Product.Create(), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate(TValue value, Func<TValue, TValue, TValue> updater)
        {
            return SetOrElseUpdate(Product.Create(), value, updater);
        }

        /// <summary>
        /// Returns a new cube containing only the values that pass the specified predicate.
        /// </summary>
        public DataCube0<TValue> Where(Func<IProduct0, TValue, bool> predicate)
        {
            return Where<DataCube0<TValue>>(predicate);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> Transform(Func<IProduct0, IProduct0> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> MultiTransform(Func<IProduct0, IEnumerable<IProduct0>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Returns canonical position corresponding to the specified product.
        /// </summary>
        protected override IProduct0 ToCanonicalPosition(IProduct0 position)
        {
            return Product.Create(position);
        }
    }

    /// <summary>
    /// A 1-dimensional data cube.
    /// </summary>
    public class DataCube1<P1, TValue> : DataCube<IProduct1<P1>, TValue>
    {
        /// <summary>
        /// Creates an empty 1-dimensional data cube. 
        /// </summary>
        public DataCube1()
        {
            Domain1Counts = new Dictionary<IProduct1<P1>, int>();
        }

        /// <summary>
        /// Creates a 1-dimensional data cube filled with the specified data. If multiple values with the same position
        /// appear among the initial data, last one is used.
        /// </summary>
        public DataCube1(IEnumerable<IProduct2<IProduct1<P1>, TValue>> initialData)
            : this()
        {
            foreach (var d in initialData)
            {
                Set(d.ProductValue1, d.ProductValue2);
            }
        }

        /// <summary>
        /// Creates a 1-dimensional data cube filled with the specified data. If multiple values with the same position
        /// appear among the initial data, last one is used.
        /// </summary>
        public DataCube1(IEnumerable<IProduct2<P1, TValue>> initialData)
            : this()
        {
            foreach (var d in initialData)
            {
                Set(d.ExceptValue2, d.ProductValue2);
            }
        }

        /// <summary>
        /// Positions of values in the first dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P1> Domain1
        {
            get { return Domain1Counts.Keys.Select(p => p.ProductValue1); }
        }

        private Dictionary<IProduct1<P1>, int> Domain1Counts { get; set; }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<P1, TValue> a)
        {
            ForEach((position, value) => a(position.ProductValue1, value));
        }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(P1 p1)
        {
            return Contains(Product.Create(p1));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public IOption<TValue> Get(P1 p1)
        {
            return Get(Product.Create(p1));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(P1 p1, Func<Unit, TValue> setter)
        {
            return GetOrElseSet(Product.Create(p1), setter);
        }
        
        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(IProduct1<P1> position, TValue value)
        {
            AddDomain(Domain1Counts, position.ProductValue1);
            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(P1 p1, TValue value)
        {
            return Set(Product.Create(p1), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate(P1 p1, TValue value, Func<TValue, TValue, TValue> updater)
        {
            return SetOrElseUpdate(Product.Create(p1), value, updater);
        }

        /// <summary>
        /// Returns a new cube containing only the values that pass the specified predicate.
        /// </summary>
        public DataCube1<P1, TValue> Where(Func<IProduct1<P1>, TValue, bool> predicate)
        {
            return Where<DataCube1<P1, TValue>>(predicate);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> Transform(Func<IProduct1<P1>, IProduct0> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> MultiTransform(Func<IProduct1<P1>, IEnumerable<IProduct0>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> Transform<Q1>(Func<IProduct1<P1>, IProduct1<Q1>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> MultiTransform<Q1>(Func<IProduct1<P1>, IEnumerable<IProduct1<Q1>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 1-dimensional cube into a 0-dimensional cube by excluding the dimension 1.
        /// All values whose position differ just in dimension 1 (their positions without dimension 1 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 1.
        /// </summary>
        public DataCube0<TValue> RollUpDimension1(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue1, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 1. The slices are 0-dimensional cubes without dimension 1 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P1, DataCube0<TValue>> SliceDimension1()
        {
            var slices = new DataCube1<P1, DataCube0<TValue>>();
            ForEach((position, value) =>
            {
                var slice = slices.GetOrElseSet(position.ProductValue1, _ => new DataCube0<TValue>());
                slice.Set(position.ExceptValue1, value);
            });
            return slices;
        }

        /// <summary>
        /// Returns canonical position corresponding to the specified product.
        /// </summary>
        protected override IProduct1<P1> ToCanonicalPosition(IProduct1<P1> position)
        {
            return Product.Create(position);
        }
    }

    /// <summary>
    /// A 2-dimensional data cube.
    /// </summary>
    public class DataCube2<P1, P2, TValue> : DataCube<IProduct2<P1, P2>, TValue>
    {
        /// <summary>
        /// Creates an empty 2-dimensional data cube. 
        /// </summary>
        public DataCube2()
        {
            Domain1Counts = new Dictionary<IProduct1<P1>, int>();
            Domain2Counts = new Dictionary<IProduct1<P2>, int>();
        }

        /// <summary>
        /// Creates a 2-dimensional data cube filled with the specified data. If multiple values with the same position
        /// appear among the initial data, last one is used.
        /// </summary>
        public DataCube2(IEnumerable<IProduct2<IProduct2<P1, P2>, TValue>> initialData)
            : this()
        {
            foreach (var d in initialData)
            {
                Set(d.ProductValue1, d.ProductValue2);
            }
        }

        /// <summary>
        /// Creates a 2-dimensional data cube filled with the specified data. If multiple values with the same position
        /// appear among the initial data, last one is used.
        /// </summary>
        public DataCube2(IEnumerable<IProduct3<P1, P2, TValue>> initialData)
            : this()
        {
            foreach (var d in initialData)
            {
                Set(d.ExceptValue3, d.ProductValue3);
            }
        }

        /// <summary>
        /// Positions of values in the first dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P1> Domain1
        {
            get { return Domain1Counts.Keys.Select(p => p.ProductValue1); }
        }

        /// <summary>
        /// Positions of values in the second dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P2> Domain2
        {
            get { return Domain2Counts.Keys.Select(p => p.ProductValue1); }
        }

        private Dictionary<IProduct1<P1>, int> Domain1Counts { get; set; }

        private Dictionary<IProduct1<P2>, int> Domain2Counts { get; set; }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<P1, P2, TValue> a)
        {
            ForEach((position, value) => a(position.ProductValue1, position.ProductValue2, value));
        }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(P1 p1, P2 p2)
        {
            return Contains(Product.Create(p1, p2));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public IOption<TValue> Get(P1 p1, P2 p2)
        {
            return Get(Product.Create(p1, p2));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(P1 p1, P2 p2, Func<Unit, TValue> setter)
        {
            return GetOrElseSet(Product.Create(p1, p2), setter);
        }
        
        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(IProduct2<P1, P2> position, TValue value)
        {
            AddDomain(Domain1Counts, position.ProductValue1);
            AddDomain(Domain2Counts, position.ProductValue2);
            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(P1 p1, P2 p2, TValue value)
        {
            return Set(Product.Create(p1, p2), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate(P1 p1, P2 p2, TValue value, Func<TValue, TValue, TValue> updater)
        {
            return SetOrElseUpdate(Product.Create(p1, p2), value, updater);
        }

        /// <summary>
        /// Returns a new cube containing only the values that pass the specified predicate.
        /// </summary>
        public DataCube2<P1, P2, TValue> Where(Func<IProduct2<P1, P2>, TValue, bool> predicate)
        {
            return Where<DataCube2<P1, P2, TValue>>(predicate);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> Transform(Func<IProduct2<P1, P2>, IProduct0> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> MultiTransform(Func<IProduct2<P1, P2>, IEnumerable<IProduct0>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> Transform<Q1>(Func<IProduct2<P1, P2>, IProduct1<Q1>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> MultiTransform<Q1>(Func<IProduct2<P1, P2>, IEnumerable<IProduct1<Q1>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 2-dimensional cube into a 1-dimensional cube by excluding the dimension 1.
        /// All values whose position differ just in dimension 1 (their positions without dimension 1 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 1.
        /// </summary>
        public DataCube1<P2, TValue> RollUpDimension1(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue1, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 1. The slices are 1-dimensional cubes without dimension 1 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P1, DataCube1<P2, TValue>> SliceDimension1()
        {
            var slices = new DataCube1<P1, DataCube1<P2, TValue>>();
            ForEach((position, value) =>
            {
                var slice = slices.GetOrElseSet(position.ProductValue1, _ => new DataCube1<P2, TValue>());
                slice.Set(position.ExceptValue1, value);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> Transform<Q1, Q2>(Func<IProduct2<P1, P2>, IProduct2<Q1, Q2>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> MultiTransform<Q1, Q2>(Func<IProduct2<P1, P2>, IEnumerable<IProduct2<Q1, Q2>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 2-dimensional cube into a 1-dimensional cube by excluding the dimension 2.
        /// All values whose position differ just in dimension 2 (their positions without dimension 2 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 2.
        /// </summary>
        public DataCube1<P1, TValue> RollUpDimension2(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue2, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 2. The slices are 1-dimensional cubes without dimension 2 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P2, DataCube1<P1, TValue>> SliceDimension2()
        {
            var slices = new DataCube1<P2, DataCube1<P1, TValue>>();
            ForEach((position, value) =>
            {
                var slice = slices.GetOrElseSet(position.ProductValue2, _ => new DataCube1<P1, TValue>());
                slice.Set(position.ExceptValue2, value);
            });
            return slices;
        }

        /// <summary>
        /// Returns canonical position corresponding to the specified product.
        /// </summary>
        protected override IProduct2<P1, P2> ToCanonicalPosition(IProduct2<P1, P2> position)
        {
            return Product.Create(position);
        }
    }

    /// <summary>
    /// A 3-dimensional data cube.
    /// </summary>
    public class DataCube3<P1, P2, P3, TValue> : DataCube<IProduct3<P1, P2, P3>, TValue>
    {
        /// <summary>
        /// Creates an empty 3-dimensional data cube. 
        /// </summary>
        public DataCube3()
        {
            Domain1Counts = new Dictionary<IProduct1<P1>, int>();
            Domain2Counts = new Dictionary<IProduct1<P2>, int>();
            Domain3Counts = new Dictionary<IProduct1<P3>, int>();
        }

        /// <summary>
        /// Creates a 3-dimensional data cube filled with the specified data. If multiple values with the same position
        /// appear among the initial data, last one is used.
        /// </summary>
        public DataCube3(IEnumerable<IProduct2<IProduct3<P1, P2, P3>, TValue>> initialData)
            : this()
        {
            foreach (var d in initialData)
            {
                Set(d.ProductValue1, d.ProductValue2);
            }
        }

        /// <summary>
        /// Creates a 3-dimensional data cube filled with the specified data. If multiple values with the same position
        /// appear among the initial data, last one is used.
        /// </summary>
        public DataCube3(IEnumerable<IProduct4<P1, P2, P3, TValue>> initialData)
            : this()
        {
            foreach (var d in initialData)
            {
                Set(d.ExceptValue4, d.ProductValue4);
            }
        }

        /// <summary>
        /// Positions of values in the first dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P1> Domain1
        {
            get { return Domain1Counts.Keys.Select(p => p.ProductValue1); }
        }

        /// <summary>
        /// Positions of values in the second dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P2> Domain2
        {
            get { return Domain2Counts.Keys.Select(p => p.ProductValue1); }
        }

        /// <summary>
        /// Positions of values in the third dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P3> Domain3
        {
            get { return Domain3Counts.Keys.Select(p => p.ProductValue1); }
        }

        private Dictionary<IProduct1<P1>, int> Domain1Counts { get; set; }

        private Dictionary<IProduct1<P2>, int> Domain2Counts { get; set; }

        private Dictionary<IProduct1<P3>, int> Domain3Counts { get; set; }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<P1, P2, P3, TValue> a)
        {
            ForEach((position, value) => a(position.ProductValue1, position.ProductValue2, position.ProductValue3, value));
        }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(P1 p1, P2 p2, P3 p3)
        {
            return Contains(Product.Create(p1, p2, p3));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public IOption<TValue> Get(P1 p1, P2 p2, P3 p3)
        {
            return Get(Product.Create(p1, p2, p3));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(P1 p1, P2 p2, P3 p3, Func<Unit, TValue> setter)
        {
            return GetOrElseSet(Product.Create(p1, p2, p3), setter);
        }
        
        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(IProduct3<P1, P2, P3> position, TValue value)
        {
            AddDomain(Domain1Counts, position.ProductValue1);
            AddDomain(Domain2Counts, position.ProductValue2);
            AddDomain(Domain3Counts, position.ProductValue3);
            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(P1 p1, P2 p2, P3 p3, TValue value)
        {
            return Set(Product.Create(p1, p2, p3), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate(P1 p1, P2 p2, P3 p3, TValue value, Func<TValue, TValue, TValue> updater)
        {
            return SetOrElseUpdate(Product.Create(p1, p2, p3), value, updater);
        }

        /// <summary>
        /// Returns a new cube containing only the values that pass the specified predicate.
        /// </summary>
        public DataCube3<P1, P2, P3, TValue> Where(Func<IProduct3<P1, P2, P3>, TValue, bool> predicate)
        {
            return Where<DataCube3<P1, P2, P3, TValue>>(predicate);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> Transform(Func<IProduct3<P1, P2, P3>, IProduct0> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> MultiTransform(Func<IProduct3<P1, P2, P3>, IEnumerable<IProduct0>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> Transform<Q1>(Func<IProduct3<P1, P2, P3>, IProduct1<Q1>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> MultiTransform<Q1>(Func<IProduct3<P1, P2, P3>, IEnumerable<IProduct1<Q1>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 3-dimensional cube into a 2-dimensional cube by excluding the dimension 1.
        /// All values whose position differ just in dimension 1 (their positions without dimension 1 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 1.
        /// </summary>
        public DataCube2<P2, P3, TValue> RollUpDimension1(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue1, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 1. The slices are 2-dimensional cubes without dimension 1 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P1, DataCube2<P2, P3, TValue>> SliceDimension1()
        {
            var slices = new DataCube1<P1, DataCube2<P2, P3, TValue>>();
            ForEach((position, value) =>
            {
                var slice = slices.GetOrElseSet(position.ProductValue1, _ => new DataCube2<P2, P3, TValue>());
                slice.Set(position.ExceptValue1, value);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> Transform<Q1, Q2>(Func<IProduct3<P1, P2, P3>, IProduct2<Q1, Q2>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> MultiTransform<Q1, Q2>(Func<IProduct3<P1, P2, P3>, IEnumerable<IProduct2<Q1, Q2>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 3-dimensional cube into a 2-dimensional cube by excluding the dimension 2.
        /// All values whose position differ just in dimension 2 (their positions without dimension 2 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 2.
        /// </summary>
        public DataCube2<P1, P3, TValue> RollUpDimension2(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue2, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 2. The slices are 2-dimensional cubes without dimension 2 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P2, DataCube2<P1, P3, TValue>> SliceDimension2()
        {
            var slices = new DataCube1<P2, DataCube2<P1, P3, TValue>>();
            ForEach((position, value) =>
            {
                var slice = slices.GetOrElseSet(position.ProductValue2, _ => new DataCube2<P1, P3, TValue>());
                slice.Set(position.ExceptValue2, value);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube3<Q1, Q2, Q3, TValue> Transform<Q1, Q2, Q3>(Func<IProduct3<P1, P2, P3>, IProduct3<Q1, Q2, Q3>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct3<Q1, Q2, Q3>, DataCube3<Q1, Q2, Q3, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube3<Q1, Q2, Q3, TValue> MultiTransform<Q1, Q2, Q3>(Func<IProduct3<P1, P2, P3>, IEnumerable<IProduct3<Q1, Q2, Q3>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct3<Q1, Q2, Q3>, DataCube3<Q1, Q2, Q3, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 3-dimensional cube into a 2-dimensional cube by excluding the dimension 3.
        /// All values whose position differ just in dimension 3 (their positions without dimension 3 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 3.
        /// </summary>
        public DataCube2<P1, P2, TValue> RollUpDimension3(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue3, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 3. The slices are 2-dimensional cubes without dimension 3 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P3, DataCube2<P1, P2, TValue>> SliceDimension3()
        {
            var slices = new DataCube1<P3, DataCube2<P1, P2, TValue>>();
            ForEach((position, value) =>
            {
                var slice = slices.GetOrElseSet(position.ProductValue3, _ => new DataCube2<P1, P2, TValue>());
                slice.Set(position.ExceptValue3, value);
            });
            return slices;
        }

        /// <summary>
        /// Returns canonical position corresponding to the specified product.
        /// </summary>
        protected override IProduct3<P1, P2, P3> ToCanonicalPosition(IProduct3<P1, P2, P3> position)
        {
            return Product.Create(position);
        }
    }

    /// <summary>
    /// A 4-dimensional data cube.
    /// </summary>
    public class DataCube4<P1, P2, P3, P4, TValue> : DataCube<IProduct4<P1, P2, P3, P4>, TValue>
    {
        /// <summary>
        /// Creates an empty 4-dimensional data cube. 
        /// </summary>
        public DataCube4()
        {
            Domain1Counts = new Dictionary<IProduct1<P1>, int>();
            Domain2Counts = new Dictionary<IProduct1<P2>, int>();
            Domain3Counts = new Dictionary<IProduct1<P3>, int>();
            Domain4Counts = new Dictionary<IProduct1<P4>, int>();
        }

        /// <summary>
        /// Creates a 4-dimensional data cube filled with the specified data. If multiple values with the same position
        /// appear among the initial data, last one is used.
        /// </summary>
        public DataCube4(IEnumerable<IProduct2<IProduct4<P1, P2, P3, P4>, TValue>> initialData)
            : this()
        {
            foreach (var d in initialData)
            {
                Set(d.ProductValue1, d.ProductValue2);
            }
        }

        /// <summary>
        /// Creates a 4-dimensional data cube filled with the specified data. If multiple values with the same position
        /// appear among the initial data, last one is used.
        /// </summary>
        public DataCube4(IEnumerable<IProduct5<P1, P2, P3, P4, TValue>> initialData)
            : this()
        {
            foreach (var d in initialData)
            {
                Set(d.ExceptValue5, d.ProductValue5);
            }
        }

        /// <summary>
        /// Positions of values in the first dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P1> Domain1
        {
            get { return Domain1Counts.Keys.Select(p => p.ProductValue1); }
        }

        /// <summary>
        /// Positions of values in the second dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P2> Domain2
        {
            get { return Domain2Counts.Keys.Select(p => p.ProductValue1); }
        }

        /// <summary>
        /// Positions of values in the third dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P3> Domain3
        {
            get { return Domain3Counts.Keys.Select(p => p.ProductValue1); }
        }

        /// <summary>
        /// Positions of values in the fourth dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P4> Domain4
        {
            get { return Domain4Counts.Keys.Select(p => p.ProductValue1); }
        }

        private Dictionary<IProduct1<P1>, int> Domain1Counts { get; set; }

        private Dictionary<IProduct1<P2>, int> Domain2Counts { get; set; }

        private Dictionary<IProduct1<P3>, int> Domain3Counts { get; set; }

        private Dictionary<IProduct1<P4>, int> Domain4Counts { get; set; }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<P1, P2, P3, P4, TValue> a)
        {
            ForEach((position, value) => a(position.ProductValue1, position.ProductValue2, position.ProductValue3, position.ProductValue4, value));
        }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(P1 p1, P2 p2, P3 p3, P4 p4)
        {
            return Contains(Product.Create(p1, p2, p3, p4));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public IOption<TValue> Get(P1 p1, P2 p2, P3 p3, P4 p4)
        {
            return Get(Product.Create(p1, p2, p3, p4));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(P1 p1, P2 p2, P3 p3, P4 p4, Func<Unit, TValue> setter)
        {
            return GetOrElseSet(Product.Create(p1, p2, p3, p4), setter);
        }
        
        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(IProduct4<P1, P2, P3, P4> position, TValue value)
        {
            AddDomain(Domain1Counts, position.ProductValue1);
            AddDomain(Domain2Counts, position.ProductValue2);
            AddDomain(Domain3Counts, position.ProductValue3);
            AddDomain(Domain4Counts, position.ProductValue4);
            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(P1 p1, P2 p2, P3 p3, P4 p4, TValue value)
        {
            return Set(Product.Create(p1, p2, p3, p4), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate(P1 p1, P2 p2, P3 p3, P4 p4, TValue value, Func<TValue, TValue, TValue> updater)
        {
            return SetOrElseUpdate(Product.Create(p1, p2, p3, p4), value, updater);
        }

        /// <summary>
        /// Returns a new cube containing only the values that pass the specified predicate.
        /// </summary>
        public DataCube4<P1, P2, P3, P4, TValue> Where(Func<IProduct4<P1, P2, P3, P4>, TValue, bool> predicate)
        {
            return Where<DataCube4<P1, P2, P3, P4, TValue>>(predicate);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> Transform(Func<IProduct4<P1, P2, P3, P4>, IProduct0> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> MultiTransform(Func<IProduct4<P1, P2, P3, P4>, IEnumerable<IProduct0>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> Transform<Q1>(Func<IProduct4<P1, P2, P3, P4>, IProduct1<Q1>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> MultiTransform<Q1>(Func<IProduct4<P1, P2, P3, P4>, IEnumerable<IProduct1<Q1>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 4-dimensional cube into a 3-dimensional cube by excluding the dimension 1.
        /// All values whose position differ just in dimension 1 (their positions without dimension 1 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 1.
        /// </summary>
        public DataCube3<P2, P3, P4, TValue> RollUpDimension1(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue1, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 1. The slices are 3-dimensional cubes without dimension 1 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P1, DataCube3<P2, P3, P4, TValue>> SliceDimension1()
        {
            var slices = new DataCube1<P1, DataCube3<P2, P3, P4, TValue>>();
            ForEach((position, value) =>
            {
                var slice = slices.GetOrElseSet(position.ProductValue1, _ => new DataCube3<P2, P3, P4, TValue>());
                slice.Set(position.ExceptValue1, value);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> Transform<Q1, Q2>(Func<IProduct4<P1, P2, P3, P4>, IProduct2<Q1, Q2>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> MultiTransform<Q1, Q2>(Func<IProduct4<P1, P2, P3, P4>, IEnumerable<IProduct2<Q1, Q2>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 4-dimensional cube into a 3-dimensional cube by excluding the dimension 2.
        /// All values whose position differ just in dimension 2 (their positions without dimension 2 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 2.
        /// </summary>
        public DataCube3<P1, P3, P4, TValue> RollUpDimension2(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue2, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 2. The slices are 3-dimensional cubes without dimension 2 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P2, DataCube3<P1, P3, P4, TValue>> SliceDimension2()
        {
            var slices = new DataCube1<P2, DataCube3<P1, P3, P4, TValue>>();
            ForEach((position, value) =>
            {
                var slice = slices.GetOrElseSet(position.ProductValue2, _ => new DataCube3<P1, P3, P4, TValue>());
                slice.Set(position.ExceptValue2, value);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube3<Q1, Q2, Q3, TValue> Transform<Q1, Q2, Q3>(Func<IProduct4<P1, P2, P3, P4>, IProduct3<Q1, Q2, Q3>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct3<Q1, Q2, Q3>, DataCube3<Q1, Q2, Q3, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube3<Q1, Q2, Q3, TValue> MultiTransform<Q1, Q2, Q3>(Func<IProduct4<P1, P2, P3, P4>, IEnumerable<IProduct3<Q1, Q2, Q3>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct3<Q1, Q2, Q3>, DataCube3<Q1, Q2, Q3, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 4-dimensional cube into a 3-dimensional cube by excluding the dimension 3.
        /// All values whose position differ just in dimension 3 (their positions without dimension 3 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 3.
        /// </summary>
        public DataCube3<P1, P2, P4, TValue> RollUpDimension3(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue3, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 3. The slices are 3-dimensional cubes without dimension 3 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P3, DataCube3<P1, P2, P4, TValue>> SliceDimension3()
        {
            var slices = new DataCube1<P3, DataCube3<P1, P2, P4, TValue>>();
            ForEach((position, value) =>
            {
                var slice = slices.GetOrElseSet(position.ProductValue3, _ => new DataCube3<P1, P2, P4, TValue>());
                slice.Set(position.ExceptValue3, value);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube4<Q1, Q2, Q3, Q4, TValue> Transform<Q1, Q2, Q3, Q4>(Func<IProduct4<P1, P2, P3, P4>, IProduct4<Q1, Q2, Q3, Q4>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<IProduct4<Q1, Q2, Q3, Q4>, DataCube4<Q1, Q2, Q3, Q4, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube4<Q1, Q2, Q3, Q4, TValue> MultiTransform<Q1, Q2, Q3, Q4>(Func<IProduct4<P1, P2, P3, P4>, IEnumerable<IProduct4<Q1, Q2, Q3, Q4>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<IProduct4<Q1, Q2, Q3, Q4>, DataCube4<Q1, Q2, Q3, Q4, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 4-dimensional cube into a 3-dimensional cube by excluding the dimension 4.
        /// All values whose position differ just in dimension 4 (their positions without dimension 4 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 4.
        /// </summary>
        public DataCube3<P1, P2, P3, TValue> RollUpDimension4(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue4, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 4. The slices are 3-dimensional cubes without dimension 4 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P4, DataCube3<P1, P2, P3, TValue>> SliceDimension4()
        {
            var slices = new DataCube1<P4, DataCube3<P1, P2, P3, TValue>>();
            ForEach((position, value) =>
            {
                var slice = slices.GetOrElseSet(position.ProductValue4, _ => new DataCube3<P1, P2, P3, TValue>());
                slice.Set(position.ExceptValue4, value);
            });
            return slices;
        }

        /// <summary>
        /// Returns canonical position corresponding to the specified product.
        /// </summary>
        protected override IProduct4<P1, P2, P3, P4> ToCanonicalPosition(IProduct4<P1, P2, P3, P4> position)
        {
            return Product.Create(position);
        }
    }

}