<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="../../CodeGen/Helpers.ttinclude" #>
using System;
using System.Collections.Generic;
using System.Linq;

namespace FuncSharp
{
<# for (var i = 0; i < 5; i++) { #>
    /// <summary>
    /// A <#= i #>-dimensional data cube.
    /// </summary>
    public class <#= DataCubeType(i) #> : DataCube<<#= ProductType(i, name: "P") #>, TValue>
    {
        public DataCube<#= i #>()
        {
<#      for (var j = 1; j <= i; j++) { #>
            Domain<#= j #>Counts = new Dictionary<IProduct1<P<#= j #>>, int>();
<#      } #>
        }

<#      if (i == 0) { #>
        /// <summary>
        /// The only value in the cube.
        /// </summary>
        public IOption<TValue> Value 
        { 
            get { return Get(); }
        }

<#      } #>
<#      for (var j = 1; j <= i; j++) { #>
        /// <summary>
        /// Positions of values in the <#= GetLowerOrdinal(j) #> dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P<#= j #>> Domain<#= j #>
        {
            get { return Domain<#= j #>Counts.Keys.Select(p => p.ProductValue1); }
        }

<#      } #>
<#      for (var j = 1; j <= i; j++) { #>
        private Dictionary<IProduct1<P<#= j #>>, int> Domain<#= j #>Counts { get; set; }

<#      } #>
        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(<#= Parameters(i, name: "P") #>)
        {
            return Contains(Product.Create(<#= Values(i, name: "P") #>));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public IOption<TValue> Get(<#= Parameters(i, name: "P") #>)
        {
            return Get(Product.Create(<#= Values(i, name: "P") #>));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(<#= Parameters(i, name: "P", appendSeparator: true) #>Func<TValue> setter)
        {
            return GetOrElseSet(Product.Create(<#= Values(i, name: "P") #>), setter);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(<#= ProductType(i, name: "P") #> position, TValue value)
        {
<#      for (var j = 1; j <= i; j++) { #>
            AddDomain(Domain<#= j #>Counts, position.ProductValue<#= j #>);
<#      } #>

            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(<#= Parameters(i, name: "P", appendSeparator: true) #>TValue value)
        {
            return Set(Product.Create(<#= Values(i, name: "P") #>), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public void SetOrElseUpdate(<#= Parameters(i, name: "P", appendSeparator: true) #>TValue value, Func<TValue, TValue, TValue> updater)
        {
            SetOrElseUpdate(Product.Create(<#= Values(i, name: "P") #>), value, updater);
        }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<<#= Types(i, name: "P", appendSeparator: true) #>TValue> a)
        {
            ForEach((position, value) => a(<#= Properties(i, name: "ProductValue", accessor: "position.", appendSeparator: true) #>value));
        }
    }

<# } #>
}